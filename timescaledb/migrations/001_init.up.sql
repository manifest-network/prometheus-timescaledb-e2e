BEGIN;

-- The public schema
create schema api;

-- Internal schema
create schema internal;

-- Per-network schema
create schema IF not exists testnet;
create schema IF not exists mainnet;
create schema IF not exists common;
create schema IF not exists cumsum;
create schema IF not exists geo;

-- Anonymous role for web access
create role web_anon nologin;
grant usage on schema api to web_anon;
grant usage on schema internal to web_anon;

-- Trusted user for web access
create role authenticator noinherit nologin;
grant web_anon to authenticator;

-- Dedicated role for writing to the database
create role writer nologin;
grant usage on schema api to writer;
grant usage on schema internal to writer;
grant writer to authenticator;

-- Excluded address table
CREATE TABLE internal.excluded_addresses (
    id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    value TEXT NOT NULL UNIQUE
);
GRANT SELECT, INSERT, DELETE ON internal.excluded_addresses TO writer;
GRANT SELECT ON internal.excluded_addresses TO web_anon;

-- Return all excluded addresses as an array
CREATE OR REPLACE FUNCTION api.get_excluded_addresses()
RETURNS TEXT[] AS $$
  SELECT array_agg(value) FROM internal.excluded_addresses;
$$ LANGUAGE sql STABLE;
GRANT EXECUTE ON FUNCTION api.get_excluded_addresses TO web_anon;

-- Add a new excluded address to the table
CREATE OR REPLACE FUNCTION api.add_excluded_address(_value TEXT)
RETURNS VOID AS $$
BEGIN
  INSERT INTO internal.excluded_addresses(value)
  VALUES (_value)
  ON CONFLICT (value) DO NOTHING;
END;
$$ LANGUAGE plpgsql VOLATILE;

-- Remove an excluded address from the table
CREATE OR REPLACE FUNCTION api.rm_excluded_address(_value TEXT)
RETURNS VOID AS $$
BEGIN
  DELETE FROM internal.excluded_addresses
  WHERE value = _value;
END;
$$ LANGUAGE plpgsql VOLATILE;

-- Web anon should not be able to execute these functions
REVOKE EXECUTE ON FUNCTION api.add_excluded_address(TEXT) FROM PUBLIC, web_anon;
REVOKE EXECUTE ON FUNCTION api.rm_excluded_address(TEXT) FROM PUBLIC, web_anon;

-- Grant execute permissions to the writer role
GRANT EXECUTE ON FUNCTION api.add_excluded_address(TEXT) TO writer;
GRANT EXECUTE ON FUNCTION api.rm_excluded_address(TEXT) TO writer;

-- Return all metrics from the `common` schema
-- Those are metrics that are common to the entire Manifest network
CREATE OR REPLACE FUNCTION api.get_all_latest_common_metrics()
  RETURNS TABLE(
    table_name  TEXT,
    "timestamp" TIMESTAMPTZ,
    "value"     TEXT
  )
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = common, internal, public
AS $$
DECLARE
  sql TEXT;
BEGIN
  SELECT string_agg(
           format(
             '(SELECT %L AS table_name, "timestamp", "value"::TEXT FROM api.latest_%I)', -- api.latest_* views are defined in the Telegraf configuration
             t.table_name,
             t.table_name
           ),
           E'\nUNION ALL\n'
         )
    INTO sql
    FROM information_schema.tables AS t
   WHERE t.table_schema = 'common'
     AND t.table_type   = 'BASE TABLE';

  RETURN QUERY EXECUTE sql;
END;
$$;

GRANT EXECUTE
  ON FUNCTION api.get_all_latest_common_metrics()
  TO web_anon;

-- Return all metrics from the `testnet` schema
-- Those are metrics that are specific to the Manifest Ledger testnet
CREATE OR REPLACE FUNCTION api.get_all_latest_testnet_metrics()
  RETURNS TABLE(
    table_name    TEXT,
    "timestamp"   TIMESTAMPTZ,
    tags          JSONB,
    "value"       TEXT
  )
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = testnet, internal, public
AS $$
DECLARE
  sql TEXT;
BEGIN
  SELECT string_agg(
           format(
             '(SELECT %L AS table_name, "timestamp", tags, "value"::TEXT FROM api.latest_testnet_%I)', -- api.latest_testnet_* views are defined in the Telegraf configuration
             t.table_name,
             t.table_name
           ),
           E'\nUNION ALL\n'
         )
    INTO sql
    FROM information_schema.tables AS t
   WHERE t.table_schema = 'testnet'
     AND t.table_type   = 'BASE TABLE';

  RETURN QUERY EXECUTE sql;
END;
$$;

GRANT EXECUTE
  ON FUNCTION api.get_all_latest_testnet_metrics()
  TO web_anon;

-- Return all metrics from the `mainnet` schema
-- Those are metrics that are specific to the Manifest Ledger mainnet
CREATE OR REPLACE FUNCTION api.get_all_latest_mainnet_metrics()
  RETURNS TABLE(
    table_name    TEXT,
    "timestamp"   TIMESTAMPTZ,
    tags          JSONB,
    "value"       TEXT
  )
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = mainnet, internal, public
AS $$
DECLARE
  sql TEXT;
BEGIN
  SELECT string_agg(
           format(
             '(SELECT %L AS table_name, "timestamp", tags, "value"::TEXT FROM api.latest_mainnet_%I)', -- api.latest_mainnet_* views are defined in the Telegraf configuration
             t.table_name,
             t.table_name
           ),
           E'\nUNION ALL\n'
         )
    INTO sql
    FROM information_schema.tables AS t
   WHERE t.table_schema = 'mainnet'
     AND t.table_type   = 'BASE TABLE';

  RETURN QUERY EXECUTE sql;
END;
$$;

GRANT EXECUTE
  ON FUNCTION api.get_all_latest_mainnet_metrics()
  TO web_anon;

-- Return all metrics from the `cumsum` schema
CREATE OR REPLACE FUNCTION api.get_all_latest_cumsum_metrics()
  RETURNS TABLE(
    table_name  TEXT,
    "timestamp" TIMESTAMPTZ,
    "value"     TEXT
  )
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = cumsum, internal, public
AS $$
DECLARE
  sql TEXT;
BEGIN
  SELECT string_agg(
           format(
             '(SELECT %L AS table_name, "timestamp", "value"::TEXT FROM api.latest_cumsum_%I)', -- api.latest_cumsum_* views are defined in the Telegraf configuration
             t.table_name,
             t.table_name
           ),
           E'\nUNION ALL\n'
         )
    INTO sql
    FROM information_schema.tables AS t
   WHERE t.table_schema = 'cumsum'
     AND t.table_type   = 'BASE TABLE';

  RETURN QUERY EXECUTE sql;
END;
$$;

GRANT EXECUTE
  ON FUNCTION api.get_all_latest_cumsum_metrics()
  TO web_anon;

-- Pre-create the geo coordinates tables in the `common` schema
-- This allow additional optimizations for the geo coordinates queries
CREATE TABLE IF NOT EXISTS geo.manifest_geo_latitude (
  time  TIMESTAMPTZ NOT NULL,
  tags  JSONB          NOT NULL,
  value DOUBLE PRECISION,
  PRIMARY KEY (time, tags)
);

SELECT create_hypertable(
  'geo.manifest_geo_latitude',
  'time',
  if_not_exists => TRUE
);

SELECT add_retention_policy('geo.manifest_geo_latitude', INTERVAL '1 year');

CREATE TABLE IF NOT EXISTS geo.manifest_geo_longitude (
  time  TIMESTAMPTZ NOT NULL,
  tags  JSONB          NOT NULL,
  value DOUBLE PRECISION,
  PRIMARY KEY (time, tags)
);

SELECT create_hypertable(
  'geo.manifest_geo_longitude',
  'time',
  if_not_exists => TRUE
);

SELECT add_retention_policy('geo.manifest_geo_longitude', INTERVAL '1 year');

CREATE TABLE IF NOT EXISTS geo.manifest_geo_metadata (
  time  TIMESTAMPTZ NOT NULL,
  tags  JSONB          NOT NULL,
  value DOUBLE PRECISION,
  PRIMARY KEY (time, tags)
);

SELECT create_hypertable(
  'geo.manifest_geo_metadata',
  'time',
  if_not_exists => TRUE
);

SELECT add_retention_policy('geo.manifest_geo_metadata', INTERVAL '1 year');

-- Create indexes on the geo coordinates tables
CREATE INDEX ON geo.manifest_geo_latitude (( (tags ->> 'instance') ), time DESC);
CREATE INDEX ON geo.manifest_geo_longitude (( (tags ->> 'instance') ), time DESC);
CREATE INDEX ON geo.manifest_geo_metadata (( (tags ->> 'instance') ), time DESC);

-- Return the latest geo coordinates from the `geo` schema
CREATE OR REPLACE FUNCTION api.get_latest_geo_coordinates()
RETURNS TABLE (
  latitude      DOUBLE PRECISION,
  longitude     DOUBLE PRECISION,
  country_name  TEXT,
  city          TEXT
)
LANGUAGE sql
SECURITY DEFINER
SET search_path = geo, internal, public
AS $$
WITH
  latest_latitude AS (
    SELECT DISTINCT ON (tags ->> 'instance')
      (tags ->> 'instance') AS instance,
      value::DOUBLE PRECISION AS latitude,
      time
    FROM   manifest_geo_latitude
    ORDER  BY (tags ->> 'instance'), time DESC
  ),
  latest_longitude AS (
    SELECT DISTINCT ON (tags ->> 'instance')
      (tags ->> 'instance') AS instance,
      value::DOUBLE PRECISION AS longitude,
      time
    FROM   manifest_geo_longitude
    ORDER  BY (tags ->> 'instance'), time DESC
  ),
  latest_geo_metadata AS (
    SELECT DISTINCT ON (tags ->> 'instance')
      (tags ->> 'instance')    AS instance,
      (tags ->> 'country_name') AS country_name,
      (tags ->> 'city')         AS city,
      time
    FROM   manifest_geo_metadata
    ORDER  BY (tags ->> 'instance'), time DESC
  )
SELECT
  llat.latitude,
  llon.longitude,
  lmeta.country_name,
  lmeta.city
FROM  latest_latitude  AS llat
JOIN  latest_longitude AS llon
  ON llat.instance = llon.instance
JOIN  latest_geo_metadata AS lmeta
  ON llat.instance = lmeta.instance;
$$;

GRANT EXECUTE
  ON FUNCTION api.get_latest_geo_coordinates()
  TO web_anon;

COMMIT;