BEGIN;

-- The public schema
create schema if not exists api;

-- Internal schema
create schema if not exists internal;

create schema IF not exists geo;

-- Anonymous role for web access
create role web_anon nologin;
grant usage on schema api to web_anon;
grant usage on schema internal to web_anon;

-- Trusted user for web access
create role authenticator noinherit nologin;
grant web_anon to authenticator;

-- Dedicated role for writing to the database
create role writer nologin;
grant usage on schema api to writer;
grant usage on schema internal to writer;
grant writer to authenticator;

-- Excluded address table
CREATE TABLE internal.excluded_addresses (
    id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    value TEXT NOT NULL UNIQUE
);
GRANT SELECT, INSERT, DELETE ON internal.excluded_addresses TO writer;
GRANT SELECT ON internal.excluded_addresses TO web_anon;

-- Return all excluded addresses as an array
CREATE OR REPLACE FUNCTION api.get_excluded_addresses()
RETURNS TEXT[] AS $$
  SELECT array_agg(value) FROM internal.excluded_addresses;
$$ LANGUAGE sql STABLE;
GRANT EXECUTE ON FUNCTION api.get_excluded_addresses TO web_anon;

-- Add a new excluded address to the table
CREATE OR REPLACE FUNCTION api.add_excluded_address(_value TEXT)
RETURNS VOID AS $$
BEGIN
  INSERT INTO internal.excluded_addresses(value)
  VALUES (_value)
  ON CONFLICT (value) DO NOTHING;
END;
$$ LANGUAGE plpgsql VOLATILE;

-- Remove an excluded address from the table
CREATE OR REPLACE FUNCTION api.rm_excluded_address(_value TEXT)
RETURNS VOID AS $$
BEGIN
  DELETE FROM internal.excluded_addresses
  WHERE value = _value;
END;
$$ LANGUAGE plpgsql VOLATILE;

-- Web anon should not be able to execute these functions
REVOKE EXECUTE ON FUNCTION api.add_excluded_address(TEXT) FROM PUBLIC, web_anon;
REVOKE EXECUTE ON FUNCTION api.rm_excluded_address(TEXT) FROM PUBLIC, web_anon;

-- Grant execute permissions to the writer role
GRANT EXECUTE ON FUNCTION api.add_excluded_address(TEXT) TO writer;
GRANT EXECUTE ON FUNCTION api.rm_excluded_address(TEXT) TO writer;

-- Pre-create the geo coordinates tables in the `common` schema
-- This allow additional optimizations for the geo coordinates queries
DO $$
DECLARE tbl text;
BEGIN
  FOR tbl IN (
    VALUES
    ('latitude'),
    ('longitude'),
    ('metadata')
  ) LOOP
    EXECUTE format(
      $fmt$
        CREATE TABLE IF NOT EXISTS geo.manifest_geo_%1$I (
          time  TIMESTAMPTZ NOT NULL,
          tags  JSONB         NOT NULL,
          value NUMERIC,
          PRIMARY KEY (time, tags)
        );
        SELECT create_hypertable('geo.manifest_geo_%1$I', 'time', if_not_exists=>TRUE);
        SELECT add_retention_policy('geo.manifest_geo_%1$I', INTERVAL '1 year');
        CREATE INDEX ON geo.manifest_geo_%1$I (( (tags ->> 'instance') ), time DESC);
      $fmt$, tbl);
  END LOOP;
END;
$$ LANGUAGE plpgsql;

-- Return the latest geo coordinates from the `geo` schema
CREATE OR REPLACE FUNCTION api.get_latest_geo_coordinates()
RETURNS TABLE (
  latitude      NUMERIC,
  longitude     NUMERIC,
  country_name  TEXT,
  city          TEXT
)
LANGUAGE sql
SECURITY DEFINER
SET search_path = geo, internal, public
AS $$
WITH instances AS (
  SELECT DISTINCT (tags->>'instance') AS instance
  FROM manifest_geo_metadata
)
SELECT
  lat.latitude,
  lon.longitude,
  meta.country_name,
  meta.city
FROM instances inst
CROSS JOIN LATERAL (
  SELECT value::NUMERIC AS latitude
  FROM manifest_geo_latitude
  WHERE tags->>'instance' = inst.instance
  ORDER BY time DESC
  LIMIT 1
) AS lat
CROSS JOIN LATERAL (
  SELECT value::NUMERIC AS longitude
  FROM manifest_geo_longitude
  WHERE tags->>'instance' = inst.instance
  ORDER BY time DESC
  LIMIT 1
) AS lon
CROSS JOIN LATERAL (
  SELECT
    tags->>'country_name' AS country_name,
    tags->>'city'         AS city
  FROM manifest_geo_metadata
  WHERE tags->>'instance' = inst.instance
  ORDER BY time DESC
  LIMIT 1
) AS meta
WHERE lat.latitude IS NOT NULL
  AND lon.longitude IS NOT NULL
$$;

GRANT EXECUTE
  ON FUNCTION api.get_latest_geo_coordinates()
  TO web_anon;

-- Initialize the metrics tables and functions for each network
-- Regular metrics, i.e., those that are not cumulative
CREATE OR REPLACE FUNCTION internal.initialize_metric(
  p_metric_name TEXT,
  p_network TEXT)
RETURNS VOID AS $outer$
BEGIN
  EXECUTE format('create schema IF not exists %I', p_network);
  EXECUTE format(
    $fmt$
      CREATE TABLE IF NOT EXISTS %I.%I (
        "time" TIMESTAMPTZ NOT NULL,
        "tags" JSONB NOT NULL,
        "value" NUMERIC,
        PRIMARY KEY (time, tags)
      )
    $fmt$, p_network, p_metric_name
  );

  EXECUTE format(
    $fmt$
      SELECT create_hypertable('%I.%I', 'time', if_not_exists => TRUE)
    $fmt$, p_network, p_metric_name
  );

  EXECUTE format(
    $fmt$
      SELECT add_retention_policy('%I.%I', INTERVAL '1 year')
    $fmt$, p_network, p_metric_name
  );

  EXECUTE format(
    $func$
    CREATE OR REPLACE FUNCTION api.get_%1$I_agg_%2$I (
        p_interval INTERVAL,
        p_from TIMESTAMPTZ,
        p_to TIMESTAMPTZ
    )
    RETURNS TABLE (
        "timestamp" TIMESTAMPTZ,
        "value"     TEXT
    )
    LANGUAGE plpgsql
    STRICT
    SECURITY DEFINER
    SET search_path = %1$I, internal, public
    AS $body$
    BEGIN
      -- Ensure p_from is less than or equal to p_to
      IF p_from > p_to THEN
        RAISE EXCEPTION 'p_from must be less than or equal to p_to';
      END IF;

      -- Ensure p_interval is a positive interval
      IF  p_interval <= INTERVAL '0' THEN
        RAISE EXCEPTION 'p_interval must be a positive interval';
      END IF;

      -- Ensure p_interval is not larger than the time range
      IF p_interval > (p_to - p_from) THEN
        RAISE EXCEPTION 'p_interval must not be larger than the time range between p_from and p_to';
      END IF;

      RETURN QUERY
      SELECT
          time_bucket(p_interval, d.time)   AS "timestamp",
          max(d.value)::TEXT                AS "value"
      FROM %1$I.%2$I as d
      WHERE d.time >= p_from AND d.time <= p_to
      GROUP BY 1
      ORDER BY 1 DESC;
    END;
    $body$;
    $func$, p_network, p_metric_name
  );
  EXECUTE format('GRANT EXECUTE ON FUNCTION api.get_%I_agg_%I(interval, timestamptz, timestamptz) TO web_anon;', p_network, p_metric_name);

  EXECUTE format(
    $func$
      CREATE OR REPLACE VIEW api.latest_%1$I_%2$I AS
      SELECT
        d.time         AS "timestamp",
        d.value::TEXT  AS "value"
      FROM %1$I.%2$I as d
      ORDER BY d.time DESC
      LIMIT 1;
    $func$, p_network, p_metric_name
  );
  EXECUTE format('GRANT SELECT ON api.latest_%I_%I TO web_anon;', p_network, p_metric_name);
END;
$outer$ LANGUAGE plpgsql;

-- Initialize the cumulative sum metrics
-- These metrics are used to calculate cumulative values over time, not regular metrics
CREATE OR REPLACE FUNCTION internal.initialize_cumsum_metric(p_metric_name TEXT)
RETURNS VOID AS $outer$
BEGIN
  EXECUTE format('create schema IF not exists cumsum');
  EXECUTE format(
    $fmt$
      CREATE TABLE IF NOT EXISTS cumsum.%I (
        "time" TIMESTAMPTZ NOT NULL,
        "tags" JSONB NOT NULL,
        "value" NUMERIC,
        PRIMARY KEY (time, tags)
      )
    $fmt$, p_metric_name
  );

  EXECUTE format(
    $fmt$
      SELECT create_hypertable('cumsum.%I', 'time', if_not_exists => TRUE)
    $fmt$, p_metric_name
  );

  EXECUTE format(
    $fmt$
      SELECT add_retention_policy('cumsum.%I', INTERVAL '1 year')
    $fmt$, p_metric_name
  );

  EXECUTE format(
    $func$
    CREATE OR REPLACE FUNCTION api.get_cumsum_agg_%1$I (
        p_interval INTERVAL,
        p_from TIMESTAMPTZ,
        p_to TIMESTAMPTZ
    )
    RETURNS TABLE (
        "timestamp" TIMESTAMPTZ,
        "value"     TEXT
    )
    LANGUAGE plpgsql
    STRICT
    SECURITY DEFINER
    SET search_path = cumsum, internal, public
    AS $body$
    BEGIN
      -- Ensure p_from is less than or equal to p_to
      IF p_from > p_to THEN
        RAISE EXCEPTION 'p_from must be less than or equal to p_to';
      END IF;

      -- Ensure p_interval is a positive interval
      IF  p_interval <= INTERVAL '0' THEN
        RAISE EXCEPTION 'p_interval must be a positive interval';
      END IF;

      -- Ensure p_interval is not larger than the time range
      IF p_interval > (p_to - p_from) THEN
        RAISE EXCEPTION 'p_interval must not be larger than the time range between p_from and p_to';
      END IF;

      RETURN QUERY
      WITH raw AS (
        SELECT
          d.time as "time",
          SUM(sum(d.value)) OVER (ORDER BY time) AS cumulative
        FROM cumsum.%1$I as d
        GROUP BY d.time
      ),
      filtered AS (
        SELECT *
        FROM raw
        WHERE time >= p_from AND time <= p_to
      ),
      bucketed AS (
        SELECT
          time_bucket(p_interval, time) AS ts,
          MAX(cumulative)               AS mc
        FROM filtered
        GROUP BY ts
      )
      SELECT
        ts as "timestamp",
        mc::TEXT as "value"
      FROM bucketed
      ORDER BY ts;
    END;
    $body$;
    $func$, p_metric_name
  );
  EXECUTE format('GRANT EXECUTE ON FUNCTION api.get_cumsum_agg_%I(interval, timestamptz, timestamptz) TO web_anon;', p_metric_name);

  EXECUTE format(
    $func$
      CREATE OR REPLACE VIEW api.latest_cumsum_%1$I AS
      SELECT
        d.time         AS "timestamp",
        d.value::TEXT  AS "value"
      FROM cumsum.%1$I as d
      ORDER BY d.time DESC
      LIMIT 1;
    $func$, p_metric_name
  );
  EXECUTE format('GRANT SELECT ON api.latest_cumsum_%I TO web_anon;', p_metric_name);
END;
$outer$ LANGUAGE plpgsql;

-- Workaround for https://github.com/jackc/pgx/issues/1362
-- Telegraf still uses `pgx` v4
--
-- Initialize supply continuous aggregates and retention policies
DO
$outer$
DECLARE
  rec RECORD;
BEGIN
FOR rec IN (
  VALUES
    ('manifest_tokenomics_total_supply', 'testnet'),
    ('manifest_tokenomics_excluded_supply', 'testnet'),
    ('locked_tokens', 'testnet'),
    ('manifest_tokenomics_total_supply', 'mainnet'),
    ('manifest_tokenomics_excluded_supply', 'mainnet'),
    ('locked_tokens', 'mainnet')
) LOOP
  PERFORM internal.initialize_metric(rec.column1, rec.column2);
  EXECUTE format('create schema IF not exists tmp_%I', rec.column2);
  EXECUTE format('CREATE TABLE IF NOT EXISTS tmp_%I.%I ("time" TIMESTAMPTZ, "tags" JSONB, "value" TEXT, PRIMARY KEY (time, tags))', rec.column2, rec.column1);
  EXECUTE format(
    $func$
      SELECT create_hypertable('tmp_%I.%I', 'time', if_not_exists => TRUE)
    $func$, rec.column2, rec.column1
  );
  EXECUTE format(
    $func$
      SELECT add_retention_policy('tmp_%I.%I', INTERVAL '1 day')
    $func$, rec.column2, rec.column1
  );

  EXECUTE format(
    $func$
    CREATE OR REPLACE FUNCTION api.tmp_to_%2$I_%1$I()
    RETURNS trigger AS $$
    BEGIN
    INSERT INTO %2$I.%1$I(time, tags, value)
      VALUES (NEW.time, NEW.tags, NEW.value::NUMERIC)
    ON CONFLICT (time, tags)
      DO UPDATE SET value = EXCLUDED.value;
    RETURN NEW;
    END;
    $$
    LANGUAGE plpgsql;
    $func$, rec.column1, rec.column2
  );

  EXECUTE format(
    'CREATE TRIGGER trg_tmp_to_%2$I_%1$I AFTER INSERT ON tmp_%2$I.%1$I FOR EACH ROW EXECUTE FUNCTION api.tmp_to_%2$I_%1$I();',
    rec.column1, rec.column2
  );

  EXECUTE format(
    $func$
    CREATE MATERIALIZED VIEW IF NOT EXISTS %2$I.cagg_%1$I
      WITH (
        timescaledb.continuous,
        timescaledb.materialized_only = true -- Enable real-time aggregation
      )
    AS
      SELECT
        time_bucket('1 hour', d.time)        AS "timestamp",
        max(d.value::NUMERIC)                AS "value"
      FROM %2$I.%1$I as d
      GROUP BY 1
    WITH NO DATA;
    $func$, rec.column1, rec.column2
  );

  EXECUTE format(
    $func$
    SELECT add_continuous_aggregate_policy(
      '%I.cagg_%I',
      start_offset      => INTERVAL '1 year',
      end_offset        => INTERVAL '1 hour',
      schedule_interval => INTERVAL '30 minutes'
    );
    $func$, rec.column2, rec.column1
  );

END LOOP;
END;
$outer$;

-- Create functions for testnet, mainnet, cumsum, and common schemas to get the latest metrics
DO
$outer$
DECLARE
  rec RECORD;
BEGIN
FOR rec IN (
  VALUES
    ('testnet'),
    ('mainnet'),
    ('cumsum'),
    ('common')
) LOOP
  EXECUTE format(
    $func$
    CREATE OR REPLACE FUNCTION api.get_all_latest_%1$I_metrics()
      RETURNS TABLE(
        table_name    TEXT,
        "timestamp"   TIMESTAMPTZ,
        "value"       TEXT
      )
    LANGUAGE plpgsql
    SECURITY DEFINER
    SET search_path = %1$I, internal, public
    AS $body$
    DECLARE
      sql TEXT;
    BEGIN
      SELECT string_agg(
               format(
                 '(SELECT %%L AS table_name, "timestamp", "value"::TEXT FROM api.latest_%1$I_%%I)',
                 t.table_name,
                 t.table_name
               ),
               E'\nUNION ALL\n'
             )
        INTO sql
        FROM information_schema.tables AS t
       WHERE t.table_schema = '%1$I'
         AND t.table_type   = 'BASE TABLE';

      RETURN QUERY EXECUTE sql;
    END;
    $body$
    $func$, rec.column1
  );

  EXECUTE format('GRANT EXECUTE ON FUNCTION api.get_all_latest_%I_metrics() TO web_anon;', rec.column1);
END LOOP;
END;
$outer$;

-- Create functions to get the circulating supply for testnet and mainnet
DO
$outer$
DECLARE
  rec RECORD;
BEGIN
FOR rec IN (
  VALUES
    ('testnet'),
    ('mainnet')
) LOOP
  EXECUTE format(
    $func$
      CREATE OR REPLACE FUNCTION api.get_%1$I_circulating_supply(
        p_interval INTERVAL,
        p_from TIMESTAMPTZ,
        p_to   TIMESTAMPTZ
      )
      RETURNS TABLE (
        "timestamp" TIMESTAMPTZ,
        "value"    TEXT
      )
      LANGUAGE plpgsql
      SECURITY DEFINER
      SET search_path = %1$I, internal, public
      AS $$
      BEGIN
        RETURN QUERY
          SELECT
            time_bucket(p_interval, t."timestamp") AS "timestamp",
            max(
              t."value"
                - COALESCE(e."value", 0)
                - COALESCE(l."value", 0)
            )::TEXT AS "value"
          FROM cagg_manifest_tokenomics_total_supply AS t
          LEFT JOIN cagg_manifest_tokenomics_excluded_supply AS e USING ("timestamp")
          LEFT JOIN cagg_locked_tokens AS l USING ("timestamp")
          WHERE t."timestamp" BETWEEN p_from AND p_to
          GROUP BY 1
          ORDER BY 1 DESC;
      END;
      $$;
    $func$, rec.column1
  );

  EXECUTE format(
    'GRANT EXECUTE ON FUNCTION api.get_%I_circulating_supply(INTERVAL, TIMESTAMPTZ, TIMESTAMPTZ) TO web_anon;',
    rec.column1
  );

  EXECUTE format(
    $func$
    CREATE OR REPLACE VIEW api.latest_%1$I_circulating_supply AS
      SELECT
        t."timestamp",
        (t."value"
         - COALESCE(e."value", 0)
         - COALESCE(l."value", 0)
        )::TEXT AS value
      FROM %1$I.cagg_manifest_tokenomics_total_supply   AS t
      LEFT JOIN %1$I.cagg_manifest_tokenomics_excluded_supply AS e USING ("timestamp")
      LEFT JOIN %1$I.cagg_locked_tokens                    AS l USING ("timestamp")
      ORDER BY 1 DESC
      LIMIT 1;
    $func$, rec.column1
  );

  EXECUTE format(
    'GRANT SELECT ON api.latest_%I_circulating_supply TO web_anon;',
    rec.column1
  );

  EXECUTE format(
    $func$
    CREATE OR REPLACE FUNCTION api.get_latest_%1$I_circulating_supply()
      RETURNS TABLE (
        "timestamp" TIMESTAMPTZ,
        "value"     TEXT
      )
      LANGUAGE plpgsql
      SECURITY DEFINER
      SET search_path = %1$I, internal, public
      AS $$
      BEGIN
        RETURN QUERY
          SELECT t.timestamp, t.value
          FROM api.latest_%1$I_circulating_supply as t;
      END;
      $$;
    $func$, rec.column1
  );

  EXECUTE format(
    'GRANT EXECUTE ON FUNCTION api.get_latest_%I_circulating_supply() TO web_anon;',
    rec.column1
  );
  END LOOP;
END;
$outer$;

COMMIT;
