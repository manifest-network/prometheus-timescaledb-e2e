BEGIN;

-- The public schema
create schema api;

-- Internal schema for TimescaleDB
create schema internal;

-- Per-network schema
create schema IF not exists testnet;
create schema IF not exists mainnet;
create schema IF not exists common;

-- Anonymous role for web access
create role web_anon nologin;
grant usage on schema api to web_anon;

-- Trusted user for web access
create role authenticator noinherit nologin;
grant web_anon to authenticator;

-- Dedicated role for writing to the database
create role writer nologin;
grant usage on schema api to writer;
grant writer to authenticator;

-- Excluded address table
CREATE TABLE excluded_addresses (
    id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    value TEXT NOT NULL UNIQUE
);

-- Return all excluded addresses as an array
CREATE OR REPLACE FUNCTION api.get_excluded_addresses()
RETURNS TEXT[] AS $$
  SELECT array_agg(value) FROM excluded_addresses;
$$ LANGUAGE sql STABLE;

-- Add a new excluded address to the table
CREATE OR REPLACE FUNCTION api.add_excluded_address(_value TEXT)
RETURNS VOID AS $$
BEGIN
  INSERT INTO excluded_addresses(value)
  VALUES (_value)
  ON CONFLICT (value) DO NOTHING;
END;
$$ LANGUAGE plpgsql VOLATILE;

-- Remove an excluded address from the table
CREATE OR REPLACE FUNCTION api.rm_excluded_address(_value TEXT)
RETURNS VOID AS $$
BEGIN
  DELETE FROM excluded_addresses
  WHERE value = _value;
END;
$$ LANGUAGE plpgsql VOLATILE;

-- Web anon should not be able to execute these functions
REVOKE EXECUTE ON FUNCTION api.add_excluded_address(TEXT) FROM PUBLIC, web_anon;
REVOKE EXECUTE ON FUNCTION api.rm_excluded_address(TEXT) FROM PUBLIC, web_anon;

-- Grant execute permissions to the writer role
GRANT EXECUTE ON FUNCTION api.add_excluded_address(TEXT) TO writer;
GRANT EXECUTE ON FUNCTION api.rm_excluded_address(TEXT) TO writer;

-- Return all metrics from the `common` schema
-- Those are metrics that are common to the entire Manifest network
CREATE OR REPLACE FUNCTION api.get_all_latest_common_metrics()
  RETURNS TABLE(
    table_name  TEXT,
    "timestamp" TIMESTAMPTZ,
    "value"     TEXT
  )
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = common, internal, public
AS $$
DECLARE
  sql TEXT;
BEGIN
  SELECT string_agg(
           format(
             '(SELECT %L AS table_name, time, value::TEXT FROM common.%I ORDER BY time DESC LIMIT 1)',
             t.table_name,
             t.table_name
           ),
           E'\nUNION ALL\n'
         )
    INTO sql
    FROM information_schema.tables AS t
   WHERE t.table_schema = 'common'
     AND t.table_type   = 'BASE TABLE';

  RETURN QUERY EXECUTE sql;
END;
$$;

GRANT EXECUTE
  ON FUNCTION api.get_all_latest_common_metrics()
  TO web_anon;

-- Return all metrics from the `testnet` schema
-- Those are metrics that are specific to the Manifest Ledger testnet
CREATE OR REPLACE FUNCTION api.get_all_latest_testnet_metrics()
  RETURNS TABLE(
    table_name    TEXT,
    "timestamp"   TIMESTAMPTZ,
    "value"       TEXT
  )
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = testnet, internal, public
AS $$
DECLARE
  sql TEXT;
BEGIN
  SELECT string_agg(
           format(
             '(SELECT %L AS table_name, time, value::TEXT FROM testnet.%I ORDER BY time DESC LIMIT 1)',
             t.table_name,
             t.table_name
           ),
           E'\nUNION ALL\n'
         )
    INTO sql
    FROM information_schema.tables AS t
   WHERE t.table_schema = 'testnet'
     AND t.table_type   = 'BASE TABLE';

  RETURN QUERY EXECUTE sql;
END;
$$;

GRANT EXECUTE
  ON FUNCTION api.get_all_latest_testnet_metrics()
  TO web_anon;

-- Return all metrics from the `mainnet` schema
-- Those are metrics that are specific to the Manifest Ledger mainnet
CREATE OR REPLACE FUNCTION api.get_all_latest_mainnet_metrics()
  RETURNS TABLE(
    table_name    TEXT,
    "timestamp"   TIMESTAMPTZ,
    "value"       TEXT
  )
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = mainnet, internal, public
AS $$
DECLARE
  sql TEXT;
BEGIN
  SELECT string_agg(
           format(
             '(SELECT %L AS table_name, time, value::TEXT FROM mainnet.%I ORDER BY time DESC LIMIT 1)',
             t.table_name,
             t.table_name
           ),
           E'\nUNION ALL\n'
         )
    INTO sql
    FROM information_schema.tables AS t
   WHERE t.table_schema = 'mainnet'
     AND t.table_type   = 'BASE TABLE';

  RETURN QUERY EXECUTE sql;
END;
$$;

GRANT EXECUTE
  ON FUNCTION api.get_all_latest_mainnet_metrics()
  TO web_anon;

-- Return the latest geo coordinates from the `common` schema
CREATE OR REPLACE FUNCTION api.get_latest_geo_coordinates()
RETURNS TABLE (
    "latitude" DOUBLE PRECISION,
    "longitude" DOUBLE PRECISION,
    "country_name" TEXT,
    "city" TEXT
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = common, internal, public
AS $$
BEGIN
    RETURN QUERY
    WITH latest_latitude AS (
        SELECT DISTINCT ON (tags->>'instance')
            tags->>'instance' AS instance,
            value AS latitude,
            time
        FROM manifest_geo_latitude
        ORDER BY tags->>'instance', time DESC
    ),
    latest_longitude AS (
        SELECT DISTINCT ON (tags->>'instance')
            tags->>'instance' AS instance,
            value AS longitude,
            time
        FROM manifest_geo_longitude
        ORDER BY tags->>'instance', time DESC
    ),
    latest_geo_metadata AS (
        SELECT DISTINCT ON (tags->>'instance')
            tags->>'instance' AS instance,
            tags->>'country_name' AS country_name,
            tags->>'city' AS city,
            time
        FROM manifest_geo_metadata
        ORDER BY tags->>'instance', time DESC
    )
    SELECT
        llat.latitude,
        llon.longitude,
        lgi.country_name,
        lgi.city
    FROM latest_latitude llat
    JOIN latest_longitude llon ON llat.instance = llon.instance
    JOIN latest_geo_metadata lgi ON llat.instance = lgi.instance;
END;
$$;

GRANT EXECUTE
  ON FUNCTION api.get_latest_geo_coordinates()
  TO web_anon;

COMMIT;