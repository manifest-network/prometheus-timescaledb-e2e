[agent]
  interval = "10s"
  metric_batch_size = 1000
  metric_buffer_limit = 100000
  flush_interval = "10s"

[[inputs.http_listener_v2]]
  service_address = ":9273"
  paths = ["/write"]
  data_format = "prometheusremotewrite"

[[inputs.internal]]

[[processors.filter]]
  namepass = ["prometheus_remote_write"]

[[processors.starlark]]
  source = '''
def apply(metric):
    for k, v in metric.fields.items():
        # Set the Telegraf measurement to the Prometheus metric name
        metric.name = k.lower()
        if len(metric.name) > 63:
            metric.name = metric.name[:63]
        # Move the metric value under a single value field
        metric.fields["value"] = v
        metric.fields.pop(k)
    return metric
'''

# Retrieve real metric value from tag
[[processors.starlark]]
  namepass = ["manifest_tokenomics_total_supply", "manifest_tokenomics_excluded_supply", "locked_tokens", "locked_fees"]
  source = '''
def apply(metric):
    if "supply" in metric.tags:
        metric.fields["value"] = metric.tags["supply"]
    elif "excluded_supply" in metric.tags:
        metric.fields["value"] = metric.tags["excluded_supply"]
    elif "amount" in metric.tags:
        metric.fields["value"] = metric.tags["amount"]

    return metric
'''

# Write the metric as TEXT and use a trigger to convert it to NUMERIC in order to get the accurate value
#
# Workaround for https://github.com/jackc/pgx/issues/1362
# Telegraf is still using pgx v4
[[outputs.postgresql]]
  namepass = ["manifest_tokenomics_total_supply", "manifest_tokenomics_excluded_supply", "locked_tokens", "locked_fees"]
  connection = "host=timescaledb user=postgres password=postgres dbname=metrics sslmode=disable"
  column_name_length_limit = 63
  tags_as_jsonb = true
  schema = "tmp_testnet"
  tagpass = {"manifest_tier" = ["testnet"]}

# Write the metric as TEXT and use a trigger to convert it to NUMERIC in order to get the accurate value
#
# Workaround for https://github.com/jackc/pgx/issues/1362
# Telegraf is still using pgx v4
[[outputs.postgresql]]
  namepass = ["manifest_tokenomics_total_supply", "manifest_tokenomics_excluded_supply", "locked_tokens", "locked_fees"]
  connection = "host=timescaledb user=postgres password=postgres dbname=metrics sslmode=disable"
  column_name_length_limit = 63
  tags_as_jsonb = true
  schema = "tmp_mainnet"
  tagpass = {"manifest_tier" = ["mainnet"]}

[[outputs.postgresql]]
  namepass = ["blockchain_height",
      "manifest_tokenomics_denom_metadata",
      "manifest_tokenomics_token_count",
      "total_unique_user",
      "total_unique_group",
      "total_mfx_burned",
      "total_mfx_minted",
      "total_tx_count",
  ]
  connection = "host=timescaledb user=postgres password=postgres dbname=metrics sslmode=disable"
  column_name_length_limit = 63
  tags_as_jsonb = true
  schema = "testnet"

  create_templates = [
    '''
    SELECT internal.initialize_metric('{{ .table.Name }}', 'testnet');
    '''
  ]
  tagpass = {"manifest_tier" = ["testnet"]}

[[outputs.postgresql]]
  namepass = ["blockchain_height",
      "manifest_tokenomics_denom_metadata",
      "manifest_tokenomics_token_count",
      "total_unique_user",
      "total_unique_group",
      "total_mfx_burned",
      "total_mfx_minted",
      "total_tx_count",
  ]
  connection = "host=timescaledb user=postgres password=postgres dbname=metrics sslmode=disable"
  column_name_length_limit = 63
  tags_as_jsonb = true
  schema = "mainnet"

  create_templates = [
    '''
    SELECT internal.initialize_metric('{{ .table.Name }}', 'mainnet');
    '''
  ]
  tagpass = {"manifest_tier" = ["mainnet"]}

# TODO: Create continuous aggregates
[[outputs.postgresql]]
  namepass = ["web_requests", "system_tcp_sent", "system_tcp_received", "system_network_sent", "system_network_received", "decentralized_web_requests"]
  connection = "host=timescaledb user=postgres password=postgres dbname=metrics sslmode=disable"
  column_name_length_limit = 63
  tags_as_jsonb = true
  schema = "cumsum"
  create_templates = [
    '''
    SELECT internal.initialize_cumsum_metric('{{ .table.Name }}');
    ''',
  ]

[[outputs.postgresql]]
  namepass = ["manifest_geo_latitude", "manifest_geo_longitude", "manifest_geo_metadata"]
  connection = "host=timescaledb user=postgres password=postgres dbname=metrics sslmode=disable"
  column_name_length_limit = 63
  tags_as_jsonb = true
  schema = "geo"

[[outputs.postgresql]]
  namedrop = ["blockchain_height",
      "manifest_tokenomics_denom_metadata",
      "manifest_tokenomics_token_count",
      "manifest_tokenomics_total_supply",
      "total_unique_user",
      "total_unique_group",
      "total_mfx_burned",
      "total_mfx_minted",
      "total_tx_count",
      "web_requests",
      "system_tcp_sent",
      "system_tcp_received",
      "system_network_sent",
      "system_network_received",
      "decentralized_web_requests",
      "manifest_geo_metadata",
      "manifest_geo_latitude",
      "manifest_geo_longitude",
      "manifest_tokenomics_excluded_supply",
      "locked_tokens",
      "locked_fees",
  ]
  connection = "host=timescaledb user=postgres password=postgres dbname=metrics sslmode=disable"
  column_name_length_limit = 63
  tags_as_jsonb = true
  schema = "common"

  create_templates = [
    '''
    SELECT internal.initialize_metric('{{ .table.Name }}', 'common');
    ''',
  ]

[[outputs.prometheus_client]]
  listen = ":9274"
  path = "/metrics"
  expiration_interval = "60s"
  collectors_exclude = ["gocollector", "process"]
