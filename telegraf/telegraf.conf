[agent]
  interval = "10s"
  metric_batch_size = 1000
  metric_buffer_limit = 10000
  flush_interval = "10s"

[[inputs.http_listener_v2]]
  service_address = ":9273"
  paths = ["/write"]
  data_format = "prometheusremotewrite"

[[inputs.internal]]

[[processors.filter]]
  namepass = ["prometheus_remote_write"]

[[processors.starlark]]
  source = '''
def apply(metric):
    for k, v in metric.fields.items():
        # Set the Telegraf measurement to the Prometheus metric name
        metric.name = k.lower()
        if len(metric.name) > 63:
            metric.name = metric.name[:63]
        # Move the metric value under a single value field
        metric.fields["value"] = v
        metric.fields.pop(k)
    return metric
'''

[[outputs.postgresql]]
  namepass = ["blockchain_height", "manifest_tokenomics_denom_metadata", "manifest_tokenomics_token_count", "manifest_tokenomics_total_supply", "total_unique_user", "total_unique_group", "total_mfx_burned", "total_mfx_minted", "total_tx_count"]
  connection = "host=timescaledb user=postgres password=postgres dbname=metrics sslmode=disable"
  column_name_length_limit = 63
  tags_as_jsonb = true
  schema = "testnet"

  create_templates = [
    # Create the testnet hypertable and retention policy
    '''
    CREATE TABLE IF NOT EXISTS {{ .table.WithSchema "testnet" }} ("time" TIMESTAMPTZ, "tags" JSONB, "value" double precision, PRIMARY KEY (time, tags));
    SELECT create_hypertable('{{ .table.WithSchema "testnet" }}', 'time', if_not_exists => TRUE);

    {{ if not (regexMatch "^forever_" .table.Name) }}
        SELECT add_retention_policy('{{ .table.WithSchema "testnet" }}', INTERVAL '1 year');
    {{ end }}
    ''',
    # Create an aggregation function for the given table (metric)
    # This function relies on the time_bucket function from TimescaleDB to aggregate data
    '''
    CREATE OR REPLACE FUNCTION api.get_testnet_agg_{{ .table.Name }} (
        p_interval INTERVAL DEFAULT '1 hour',
        p_from TIMESTAMPTZ DEFAULT NULL,
        p_to TIMESTAMPTZ DEFAULT NULL
    )
    RETURNS TABLE (
        "timestamp" TIMESTAMPTZ,
        tags       JSONB,
        "value" TEXT
    )
    LANGUAGE sql
    SECURITY DEFINER
    SET search_path = testnet, internal, public
    AS $$$$
        SELECT
            time_bucket(p_interval, time)   AS timestamp,
            (
                SELECT jsonb_object_agg(key, value)
                    FROM jsonb_each(tags) AS t(key, value)
                WHERE key IN ('supply')
            )                                AS tags,
            avg(value)::TEXT                AS value
        FROM testnet.{{ .table.Name }}
        WHERE time >= coalesce(p_from, now() - p_interval)
            AND time <= coalesce(p_to,   now())
        GROUP BY 1, tags
        ORDER BY 1 DESC;
    $$$$;
    GRANT EXECUTE ON FUNCTION api.get_testnet_agg_{{ .table.Name }}(interval, timestamptz, timestamptz) TO web_anon;
    ''',
    # Create a view to get the latest value for the given table (metric)
    '''
    CREATE OR REPLACE VIEW api.latest_testnet_{{ .table.Name }} AS
    SELECT
      time         AS "timestamp",
      value::TEXT  AS "value"
    FROM {{ .table.WithSchema "testnet" }}
    ORDER BY time DESC
    LIMIT 1;
    GRANT SELECT ON api.latest_testnet_{{ .table.Name }} TO web_anon;
    '''
  ]
  tagpass = {"manifest_tier" = ["testnet"]}

[[outputs.postgresql]]
  namepass = ["blockchain_height", "manifest_tokenomics_denom_metadata", "manifest_tokenomics_token_count", "manifest_tokenomics_total_supply", "total_unique_user", "total_unique_group", "total_mfx_burned", "total_mfx_minted", "total_tx_count"]
  connection = "host=timescaledb user=postgres password=postgres dbname=metrics sslmode=disable"
  column_name_length_limit = 63
  tags_as_jsonb = true
  schema = "mainnet"

  create_templates = [
    # Create the mainnet hypertable and retention policy
    '''
    CREATE TABLE IF NOT EXISTS {{ .table.WithSchema "mainnet" }} ("time" TIMESTAMPTZ, "tags" JSONB, "value" double precision, PRIMARY KEY (time, tags));
    SELECT create_hypertable('{{ .table.WithSchema "mainnet" }}', 'time', if_not_exists => TRUE);

    {{ if not (regexMatch "^forever_" .table.Name) }}
      SELECT add_retention_policy('{{ .table.WithSchema "mainnet" }}', INTERVAL '1 year');
    {{ end }}
    ''',
    # Create an aggregation function for the given table (metric)
    # This function relies on the time_bucket function from TimescaleDB to aggregate data
    '''
    CREATE OR REPLACE FUNCTION api.get_mainnet_agg_{{ .table.Name }} (
        p_interval INTERVAL DEFAULT '1 hour',
        p_from TIMESTAMPTZ DEFAULT NULL,
        p_to TIMESTAMPTZ DEFAULT NULL
    )
    RETURNS TABLE (
        "timestamp" TIMESTAMPTZ,
        tags      JSONB,
        "value" TEXT
    )
    LANGUAGE sql
    SECURITY DEFINER
    SET search_path = mainnet, internal, public
    AS $$$$
        SELECT
            time_bucket(p_interval, time)   AS timestamp,
            (
               SELECT COALESCE(jsonb_object_agg(key, value), '{}'::JSONB)
                   FROM jsonb_each(tags) AS t(key, value)
               WHERE key IN ('supply')
            ) AS tags,
            avg(value)::TEXT                AS value
        FROM mainnet.{{ .table.Name }}
        WHERE time >= coalesce(p_from, now() - p_interval)
            AND time <= coalesce(p_to,   now())
        GROUP BY 1, tags
        ORDER BY 1 DESC;
    $$$$;
    GRANT EXECUTE ON FUNCTION api.get_mainnet_agg_{{ .table.Name }}(interval, timestamptz, timestamptz) TO web_anon;
    ''',
    # Create a view to get the latest value for the given table (metric)
    '''
    CREATE OR REPLACE VIEW api.latest_mainnet_{{ .table.Name }} AS
    SELECT
      time        AS "timestamp",
      (
        SELECT COALESCE(jsonb_object_agg(key, value), '{}'::JSONB)
        FROM jsonb_each(tags) AS t(key, value)
        WHERE key IN ('supply')
      )           AS tags,
      value::TEXT AS "value"
    FROM {{ .table.WithSchema "mainnet" }}
    ORDER BY time DESC
    LIMIT 1;
    GRANT SELECT ON api.latest_mainnet_{{ .table.Name }} TO web_anon;
    '''
  ]
  tagpass = {"manifest_tier" = ["mainnet"]}

[[outputs.postgresql]]
  namedrop = ["blockchain_height", "manifest_tokenomics_denom_metadata", "manifest_tokenomics_token_count", "manifest_tokenomics_total_supply", "total_unique_user", "total_unique_group", "total_mfx_burned", "total_mfx_minted", "total_tx_count"]
  connection = "host=timescaledb user=postgres password=postgres dbname=metrics sslmode=disable"
  column_name_length_limit = 63
  tags_as_jsonb = true
  schema = "common"

  create_templates = [
    # Create the common hypertable and retention policy
    '''
    CREATE TABLE IF NOT EXISTS {{ .table.WithSchema "common" }} ("time" TIMESTAMPTZ, "tags" JSONB, "value" double precision, PRIMARY KEY (time, tags));
    SELECT create_hypertable('common.{{ .table.Name }}', 'time', if_not_exists => TRUE);

    {{ if not (regexMatch "^forever_" .table.Name) }}
      SELECT add_retention_policy('common.{{ .table.Name }}', INTERVAL '1 year');
    {{ end }}
    ''',
    # Create an aggregation function for the given table (metric)
    # This function relies on the time_bucket function from TimescaleDB to aggregate data
    '''
    CREATE OR REPLACE FUNCTION api.get_agg_{{ .table.Name }} (
        p_interval INTERVAL DEFAULT '1 hour',
        p_from TIMESTAMPTZ DEFAULT NULL,
        p_to TIMESTAMPTZ DEFAULT NULL
    )
    RETURNS TABLE (
        "timestamp" TIMESTAMPTZ,
        "value" TEXT
    )
    LANGUAGE sql
    SECURITY DEFINER
    SET search_path = common, internal, public
    AS $$$$
        SELECT
            time_bucket(p_interval, time)   AS timestamp,
            avg(value)::TEXT                 AS value
        FROM common.{{ .table.Name }}
        WHERE time >= coalesce(p_from, now() - p_interval)
            AND time <= coalesce(p_to,   now())
        GROUP BY 1
        ORDER BY 1 DESC;
    $$$$;
    GRANT EXECUTE ON FUNCTION api.get_agg_{{ .table.Name }}(interval, timestamptz, timestamptz) TO web_anon;
    ''',
    # Create a view to get the latest value for the given table (metric)
    '''
    CREATE OR REPLACE VIEW api.latest_{{ .table.Name }} AS
    SELECT
      time         AS "timestamp",
      value::TEXT  AS "value"
    FROM {{ .table.WithSchema "common" }}
    ORDER BY time DESC
    LIMIT 1;
    GRANT SELECT ON api.latest_{{ .table.Name }} TO web_anon;
    '''
  ]

[[outputs.prometheus_client]]
  listen = ":9274"
  path = "/metrics"
  expiration_interval = "60s"
  collectors_exclude = ["gocollector", "process"]
